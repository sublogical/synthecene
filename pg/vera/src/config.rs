use clap::{Parser, Subcommand};
use clap_verbosity_flag::{ Verbosity, InfoLevel };
use log::{error, info };
use prost_reflect::{
    DescriptorPool,
    DynamicMessage
};
use scylla::{Session, SessionBuilder};
use tonic::{Request};
use tokio::time::Duration;
use std::path::PathBuf;

#[derive(Debug, thiserror::Error)]
enum VeraConfigError {
    #[error("Error reading config: {0}")]
    ConfigReadError(std::io::Error),

    #[error("Internal error: {0}")]
    InternalError(String),

    #[error("Error connecting to scylla: {0}")]
    ScyllaSessionError(scylla::transport::errors::NewSessionError),

    #[error("Error parsing protobuf: {0}")]
    ProtobufTextParseError(prost_reflect::text_format::ParseError),

    #[error("Error parsing protobuf: {0}")]
    ProtobufDecodeError(prost::DecodeError),
}

impl From<std::io::Error> for VeraConfigError {
    fn from(e: std::io::Error) -> Self {
        VeraConfigError::ConfigReadError(e)
    }
}

impl From<scylla::transport::errors::NewSessionError> for VeraConfigError {
    fn from(e: scylla::transport::errors::NewSessionError) -> Self {
        VeraConfigError::ScyllaSessionError(e)
    }
}

impl From<prost_reflect::text_format::ParseError> for VeraConfigError {
    fn from(e: prost_reflect::text_format::ParseError) -> Self {
        VeraConfigError::ProtobufTextParseError(e)
    }
}

impl From<prost::DecodeError> for VeraConfigError {
    fn from(e: prost::DecodeError) -> Self {
        VeraConfigError::ProtobufDecodeError(e)
    }
}

use vera::vera_api::{
    CreateUniverseRequest,
    CreateTableRequest,
    CreateColumnRequest,
    CreateTypeRequest,
    DeleteUniverseRequest,
    DeleteTableRequest,
    DeleteColumnRequest,
    DeleteTypeRequest,
};

mod service;
use service::VeraService;
use vera::vera_api::vera_server::Vera;

#[derive(Parser)]
#[command(name = "Vera-Config CLI")]
#[command(about = "Command line interface for deploying textproto based configs to the server")]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// scylla uri (e.g., "127.0.0.1:9042")
    #[arg(short = 's', long)]
    scylla_uri: Option<String>,

    /// Verbose output
    #[command(flatten)]
    verbose: Verbosity<InfoLevel>,
}

#[derive(Subcommand)]
enum Commands {
    Universe {
        #[command(subcommand)]
        command: UniverseCommands,
    },

    Table {
        #[command(subcommand)]
        command: TableCommands,
    },
    
    Column {
        #[command(subcommand)]
        command: ColumnCommands,
    },

    Type {
        #[command(subcommand)]
        command: TypeCommands,
    },
}

#[derive(Subcommand)]
enum UniverseCommands {
    Create {
        #[arg(value_name = "FILE")]
        config_path: PathBuf,
    },
    
    Delete {
        universe_uri: String,
    },
}

#[derive(Subcommand)]
enum TableCommands {
    Create {
        #[arg(value_name = "FILE")]
        config_path: PathBuf,
    },

    Delete {
        universe_uri: String,
        table_uri: String,
    },
}

#[derive(Subcommand)]
enum ColumnCommands {
    Create {
        #[arg(value_name = "FILE")]
        config_path: PathBuf,
    },
    
    Delete {
        universe_uri: String,
        table_uri: String,
        column_uri: String,
    },
}

#[derive(Subcommand)]
enum TypeCommands {
    Create {
        #[arg(value_name = "FILE")]
        config_path: PathBuf,
    }, 

    Delete {
        universe_uri: String,
        type_uri: String,
    },
}

// todo: make this work - prost_reflect::prost::Message + Default does not match the prost::Message trait. Version incompatibility?

fn parse_from_str<T: prost_reflect::prost::Message + Default>(text: &str, message_name: &str) -> Result<T, VeraConfigError> {
    // Assuming you have a file_descriptor_set.bin generated by protoc
    let file_descriptor_set = include_bytes!("../vera_api.bin");
    let pool = DescriptorPool::decode(file_descriptor_set.as_ref()).unwrap();
    let message_descriptor = pool
        .get_message_by_name(message_name)
        .unwrap();

    let dynamic_message = DynamicMessage::parse_text_format(message_descriptor, text)?;
    let message = dynamic_message.transcode_to::<T>()?;
    Ok(message)
}

#[tokio::main]
async fn main() -> Result<(), VeraConfigError> {
    // Initialize tracing
    tracing_subscriber::fmt()
        .with_env_filter("vera=debug")
        .init();

    let cli = Cli::parse();
    
    let uri = cli.scylla_uri
        .or_else(|| std::env::var("SCYLLA_URI").ok())
        .unwrap_or("127.0.0.1:9042".to_string());
    
    info!("Connecting Session to {:?}", uri);
    let session: Session = SessionBuilder::new()
        .known_node(uri)
        .connection_timeout(Duration::from_secs(3))
        .cluster_metadata_refresh_interval(Duration::from_secs(10))
        .build()
        .await?;
    info!("Session Connected");

    let vera = VeraService { session };

    let result:Result<(), VeraConfigError> = match &cli.command {
        Commands::Universe { command } => {
            match command {
                UniverseCommands::Create { config_path } => {
                    let config = std::fs::read_to_string(config_path)?;
                    let message = parse_from_str::<CreateUniverseRequest>(&config, "vera_api.CreateUniverseRequest")?;
                    vera.create_universe(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())
                },
                UniverseCommands::Delete { universe_uri } => {
                    let message = DeleteUniverseRequest {
                        universe_uri: universe_uri.to_string(),
                    };
                    vera.delete_universe(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())
                }
            }
        },
        Commands::Table { command } => {
            match command {
                TableCommands::Create { config_path } => {
                    let config = std::fs::read_to_string(config_path)?;
                    let message = parse_from_str::<CreateTableRequest>(&config, "vera_api.CreateTableRequest")?;
                    vera.create_table(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())
                },
                TableCommands::Delete { universe_uri, table_uri } => {
                    let message = DeleteTableRequest {
                        universe_uri: universe_uri.to_string(),
                        table_uri: table_uri.to_string(),
                        delete_if_not_empty: true, // todo: make this configurable
                    };
                    vera.delete_table(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())
                }
            }
        },
        Commands::Column { command } => {
            match command {
                ColumnCommands::Create { config_path } => {
                    let config = std::fs::read_to_string(config_path)?;
                    let message = parse_from_str::<CreateColumnRequest>(&config, "vera_api.CreateColumnRequest")?;
                    vera.create_column(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())
                },
                ColumnCommands::Delete { universe_uri, table_uri, column_uri } => {
                    let message = DeleteColumnRequest {
                        universe_uri: universe_uri.to_string(),
                        table_uri: table_uri.to_string(),
                        column_uris: vec![column_uri.to_string()],
                    };
                    vera.delete_column(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())
                }
            }
        },
        Commands::Type { command } => {
            match command {
                TypeCommands::Create { config_path } => {
                    let config = std::fs::read_to_string(config_path)?;
                    let message = parse_from_str::<CreateTypeRequest>(&config, "vera_api.CreateTypeRequest")?;
                    vera.create_type(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())  
                },
                TypeCommands::Delete { universe_uri, type_uri } => {
                    let message = DeleteTypeRequest {
                        universe_uri: universe_uri.to_string(),
                        type_uris: vec![type_uri.to_string()],
                    };
                    vera.delete_type(Request::new(message)).await
                        .map_err(|e| VeraConfigError::InternalError(e.to_string()))?;
                    Ok(())
                }
            }
        }
    };

    result
}
